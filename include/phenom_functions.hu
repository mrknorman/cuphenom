#ifndef PHENOM_FUNCTIONS_HU
#define PHENOM_FUNCTIONS_HU

#define BLOCK_SIZE 256

#include "units.h"

typedef struct {
    // Sampling interval (timeUnit_t):
    timeUnit_t        sampling_interval;  
    
    // Starting GW frequency (frequencyUnit_t):
    frequencyUnit_t   starting_frequency;  
    
    // Ending GW Frequency (frequencyUnit_t):
    frequencyUnit_t   ending_frequency;  
    
    // Reference GW frequency (frequencyUnit_t):
    frequencyUnit_t   reference_frequency; 
    
    // Extra time to include for all waveforms to take care of situations where 
    // the frequency is close to merger (and is sweeping rapidly) this is a few 
    // cycles at the low frequency:
    timeUnit_t extra_time;
    
    // Upper bound on the chirp time starting at starting_frequency:
    timeUnit_t chirp_time_upper_bound;
     
    // Upper bound on the plunge and merger time:
    timeUnit_t merge_time_upper_bound;
    
    // Upper bound on the ringdown time:
    timeUnit_t ringdown_time_upper_bound;
    
    // Upper bound on the total time:
    timeUnit_t total_time_upper_bound;
     
} temporal_properties_s;

__global__ void performTimeShift(
              cuFloatComplex   *h_plus_frequency, 
              cuFloatComplex   *h_cross_frequency, 
        const frequencyUnit_t   frequency_interval, 
        const float             num_samples_time_shift,
        const int32_t           num_frequency_samples
    ) {
    
    /**
     * Perform hetrodyne shift.
     * @param 
     * @see 
     * @return void
     */
    
    // Assign unique thread index for GPU calculation:
    const int32_t sample_index = blockIdx.x * blockDim.x + threadIdx.x;
    
    // If not outside array bounds, add value toa array element:
    if (sample_index < num_frequency_samples) 
	{    
        cuFloatComplex shift_c  = (cuFloatComplex) {
            0.0f,
            2.0f * (float) M_PI * (float) sample_index 
                 * frequency_interval.hertz * num_samples_time_shift
        };
		
        cuFloatComplex h_plus = 
            cuCmulf(h_plus_frequency[sample_index], cudaCExpf(shift_c));
            
        cuFloatComplex h_cross = 
            cuCmulf(h_cross_frequency[sample_index], cudaCExpf(shift_c));

        h_plus_frequency [sample_index] = h_plus;
        h_cross_frequency[sample_index] = h_cross;
    }
}

extern "C" void performTimeShiftHost(
          cuFloatComplex        *h_plus_frequency, 
          cuFloatComplex        *h_cross_frequency, 
    const temporal_properties_s  temporal_properties,
    const int32_t                num_waveform_samples,
    const frequencyUnit_t        frequency_interval
    ) {
        
    const float num_samples_time_shift = 
          round(temporal_properties.extra_time.seconds / 
          temporal_properties.sampling_interval.seconds) 
        * temporal_properties.sampling_interval.seconds;
    
    const int32_t num_frequency_samples = num_waveform_samples/2 + 1;
    
    const int32_t grid_size = ((num_frequency_samples + BLOCK_SIZE - 1) / BLOCK_SIZE);
    
    performTimeShift<<<grid_size,BLOCK_SIZE>>>(
        h_plus_frequency, 
        h_cross_frequency, 
        frequency_interval, 
        num_samples_time_shift,
        num_frequency_samples
    );
}



#endif