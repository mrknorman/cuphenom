#ifndef PHENOM_FUNCTIONS_HU
#define PHENOM_FUNCTIONS_HU

#define BLOCK_SIZE 256

#include "units.h"
#include "phenomd_structures.h"

__global__ void _performTimeShift(
              complex_waveform_axes_s waveform_axes, 
        const float                   num_samples_time_shift
    ) {
    
    /**
     * Perform hetrodyne shift.
     * @param 
     * @see 
     * @return void
     */
    
    // Assign unique thread index for GPU calculation:
    const int32_t sample_index = blockIdx.x * blockDim.x + threadIdx.x;
    
    // If not outside array bounds, add value toa array element:
    if (sample_index < waveform_axes.strain.num_samples) 
	{    
        cuFloatComplex shift_c  = (cuFloatComplex) {
            0.0f,
            2.0f * (float) M_PI * (float) sample_index 
                 * waveform_axes.frequency.interval.hertz*num_samples_time_shift
        };
		
        cuFloatComplex h_plus = 
            cuCmulf(
                waveform_axes.strain.values[sample_index].plus,
                cudaCExpf(shift_c)
            );
            
        cuFloatComplex h_cross = 
            cuCmulf(
                waveform_axes.strain.values[sample_index].cross, 
                cudaCExpf(shift_c)
            );

        waveform_axes.strain.values[sample_index].plus  = h_plus;
        waveform_axes.strain.values[sample_index].cross = h_cross;
    }
}

extern "C" int32_t performTimeShift(
          complex_waveform_axes_s waveform_axes_fd,
    const timeUnit_t              shift_duration
    ) {
    
    // Integer number of samples:
    const float num_samples_time_shift = 
        roundf(
              shift_duration.seconds
            / waveform_axes_fd.time.interval.seconds
        )*waveform_axes_fd.time.interval.seconds; 
    
    const int32_t grid_size = 
        ((waveform_axes_fd.strain.num_samples + BLOCK_SIZE - 1) / BLOCK_SIZE);
    
    _performTimeShift<<<grid_size,BLOCK_SIZE>>>(
        waveform_axes_fd,
        num_samples_time_shift
    );
    
    //XLALGPSAdd(&(*hptilde)->epoch, tshift);
    //XLALGPSAdd(&(*hctilde)->epoch, tshift);
    
    return 0;
}

__global__ void initFrequencyArray(
              frequency_array_s frequency_array, 
        const int32_t           start_index, 
        const int32_t           end_index, 
        const frequencyUnit_t   frequency_interval
    ) {
    
    /**
     * Init frequency array:
     * @param 
     * @see 
     * @return void
     */
    
    // Assign unique thread index for GPU calculation:
    const int32_t sample_index = blockIdx.x * blockDim.x + threadIdx.x;
    
    // If not outside array bounds, add value toa array element:
    if (sample_index < frequency_array.num_samples) 
	{    
        frequency_array.values[sample_index].hertz = 
            (sample_index+start_index)*frequency_interval.hertz;
    }    
}

extern "C" complex_waveform_axes_s generatePhenomD(
    const temporal_properties_s *temporal_properties,
    const int32_t                num_strain_axis_samples
    ) {
    
    const frequencyUnit_t starting_frequency = 
        temporal_properties[0].starting_frequency;
    const frequencyUnit_t ending_frequency   = 
        temporal_properties[0].ending_frequency;
    const frequencyUnit_t frequency_interval = 
        temporal_properties[0].frequency_interval;
    
    /*
    _calcNumStrainAxisSamples(
        temporal_properties,
        system_properties,
        num_strain_axis_samples,
        num_waveforms
    ); 
    */

    // Initilise frequency array using the upper and lower bounds:
    const int32_t start_index = 
        (int32_t) (starting_frequency.hertz 
            / frequency_interval.hertz);
    const int32_t end_index = 
        (int32_t) (ending_frequency.hertz 
            / frequency_interval.hertz);
        
    const int32_t num_frequency_axis_samples = end_index - start_index;
    
    // Error check indicies:
    if (end_index >= num_strain_axis_samples)
    {
        fprintf(
            stderr,
            "%s:\n"
            "Error! Calculated end_index (%i) is greater than "
            "num_frequency_axis_samples (%i)! Exiting!"
            , __func__, end_index, num_strain_axis_samples  
        );
        exit(1);
    }
    else if (start_index >= end_index)
    {
        fprintf(
            stderr,
            "%s:\n"
            "Error! Calculated start_index (%i) is greater than end_index "
            "(%i)! Exiting!"
            , __func__, start_index, end_index  
        );
        exit(1);
    }
    
    complex_strain_array_s complex_strain_array;
    cudaCallocateDeviceMemory(
        num_strain_axis_samples,
        sizeof(complex_strain_element_t),
        (void**)&(complex_strain_array.values)
    );
    complex_strain_array.num_samples = num_strain_axis_samples;
    
    frequency_array_s frequency_array;
    cudaAllocateDeviceMemory(
        num_frequency_axis_samples,
        sizeof(frequencyUnit_t),
        (void**)&(frequency_array.values)
    );
    frequency_array.num_samples = num_frequency_axis_samples;
    
    // Init Frequency Axis
    const int32_t grid_size = 
        ((num_frequency_axis_samples + BLOCK_SIZE - 1) / BLOCK_SIZE);
        
    initFrequencyArray<<<grid_size, BLOCK_SIZE>>>(
        frequency_array, 
        start_index, 
        end_index, 
        frequency_interval
    );
    
    time_array_s time_array = 
    {
        .values      = NULL,
        .interval    = initTimeSeconds(0.0f),
        .num_samples = 0
    };
    complex_waveform_axes_s waveform_axes_fd = 
    {
        .merger_time = initTimeSeconds(0.0),
        .frequency   = frequency_array,
        .time        = time_array,
        .strain      = complex_strain_array
    };
    
    return waveform_axes_fd;
}

__device__ __forceinline__ useful_powers_s _initUsefulPowers(
    const float one
    ) {
        
    const float sixth = sqrtf(one) / cbrtf(one);    
    const float m_sixth = 1.0f/sixth;
    
    useful_powers_s powers;
    
    powers.one            = one;
    powers.third          = _square(sixth);
    powers.two_thirds     = _square(powers.third);
    powers.four_thirds    = one*powers.third;
    powers.five_thirds    = powers.four_thirds*powers.third;
    powers.two            = _square(one);
    powers.seven_thirds   = powers.third*powers.two;
    powers.eight_thirds   = powers.two_thirds*powers.two;
    powers.inv            = 1.0f/one;
    powers.m_seven_sixths = powers.inv*m_sixth;
    powers.m_third        = _square(m_sixth);
    powers.m_two_thirds   = _square(powers.m_third);
    powers.m_five_thirds  = powers.inv*powers.m_two_thirds;
    
    return powers;
}


// The Newtonian term in LAL is fine and we should use exactly the same (either 
// hardcoded or call). We just use the Mathematica expression for convenience.

// Inspiral amplitude plus rho phenom coefficents. rho coefficients computed
// in rho1_fun, rho2_fun, rho3_fun functions. Amplitude is a re-expansion. 
// See 1508.07253 and Equation 29, 30 and Appendix B arXiv:1508.07253 for 
// details:
__device__ __forceinline__ float _calculateInspiralAmplitudeAnsatz(
    const useful_powers_s                 mass_frequency, 
    const amplitude_inspiral_prefactors_s prefactors
    ) {
    
    return 1.0f 
        + mass_frequency.two_thirds   * prefactors.two_thirds
        + mass_frequency.four_thirds  * prefactors.four_thirds
        + mass_frequency.five_thirds  * prefactors.five_thirds
        + mass_frequency.seven_thirds * prefactors.seven_thirds 
        + mass_frequency.eight_thirds * prefactors.eight_thirds
        + mass_frequency.one 
        * (   
            + prefactors.one 
            + mass_frequency.one*prefactors.two 
            + mass_frequency.two*prefactors.three
          );
}

//Ansatz for the merger-ringdown amplitude. Equation 19 arXiv:1508.07253:
__device__ __forceinline__ float _calculateMergerRingdownAmplitudeAnsatz(
    const useful_powers_s                 mass_frequency, 
    const amplitude_coefficients_s coefficients
    ) {
    
    const float ringdown_frequency = coefficients.ringdown_frequency;
    const float damping_time = coefficients.damping_time;
    
    const float *gamma = coefficients.merger_ringdown;
    
    const float damping_time_gamma3 = damping_time*gamma[2];
    const float fminfRD   = mass_frequency.one - ringdown_frequency;
    
    return expf( -(fminfRD)*gamma[1] / (damping_time_gamma3) )
        * (damping_time_gamma3*gamma[0]) / 
            (_square(fminfRD) + _square(damping_time_gamma3));
    }
 
// Ansatz for the intermediate amplitude. Equation 21 arXiv:1508.07253:
__device__ __forceinline__ float _calculateIntermediateAmplitudeAnsatz(
    const useful_powers_s          mass_frequency, 
    const amplitude_coefficients_s coefficients
    ) {
    
    const float Mf   = mass_frequency.one;
    const float Mf_2 = _square(Mf);
    
    const float *delta = coefficients.intermediate;
       
    return 
        + delta[0] 
        + Mf*delta[1] 
        + Mf_2*(delta[2] + Mf*delta[3] + Mf_2*delta[4]);
}

// This function computes the IMR amplitude given phenom coefficients. Defined 
// in VIII. Full IMR Waveforms arXiv:1508.07253:
__device__ float _calculateAmplitude(
        const useful_powers_s                 mass_frequency,
        const amplitude_coefficients_s        coefficients,
        const amplitude_inspiral_prefactors_s prefactors
    ) {
    // Defined in VIII. Full IMR Waveforms arXiv:1508.07253
    // The inspiral, intermediate and merger-ringdown amplitude parts
    // IMRPhenDAmplitude

    const float amplitude_prefactor = 
        prefactors.amp0 * mass_frequency.m_seven_sixths;

    // Split the calculation to just 1 of 3 possible mutually exclusive ranges:
    float amplitude_ansatz = 0.0f;
    
    // Inspiral range:
    if (mass_frequency.one < AMPLITUDE_INTERMEDIATE_START_FREQUENCY) 
    {
        amplitude_ansatz = 
            _calculateInspiralAmplitudeAnsatz(
                mass_frequency, prefactors
            );
    }
    // Merger-Ringdown range:
    else if (mass_frequency.one >= coefficients.inspiral_merger_peak_frequency) 
    {
        amplitude_ansatz = 
            _calculateMergerRingdownAmplitudeAnsatz(
                mass_frequency, coefficients
            );
    }
    // Intermediate range:
    else  
    {
        amplitude_ansatz = 
            _calculateIntermediateAmplitudeAnsatz(
                mass_frequency, coefficients
            );
    }
    
    return amplitude_prefactor*amplitude_ansatz;
}

// Ansatz for the inspiral phase. We call the LAL TF2 coefficients here. The 
// exact values of the coefficients used are given as comments in the top of 
// this file. Defined by Equation 27 and 28 arXiv:1508.07253
__device__ __forceinline__ float _calculateInspiralPhaseAnsatz(
    const useful_powers_s              mass_frequency, 
    const phase_inspiral_prefactors_s             prefactors, 
    const phase_coefficients_s  coefficients
    ) {
    // Assemble PN phasing series:
    const float v    = mass_frequency.third * CUBE_ROOT_PI;
    const float logv = logf(v);
    
    const float phase_ansatz =  
         prefactors.initial_phasing
       + prefactors.two_thirds        * mass_frequency.two_thirds
       + prefactors.third             * mass_frequency.third
       + prefactors.third_with_logv   * logv * mass_frequency.third
       + prefactors.logv              * logv
       + prefactors.minus_third       * mass_frequency.m_third
       + prefactors.minus_two_thirds  * mass_frequency.m_two_thirds
       + prefactors.minus_one         * mass_frequency.inv
       + prefactors.minus_four_thirds / mass_frequency.four_thirds
       + prefactors.minus_five_thirds * mass_frequency.m_five_thirds
       // Now add higher order terms that were calibrated for PhenomD:
       + coefficients.etaInv*
            (    prefactors.one         * mass_frequency.one 
               + prefactors.four_thirds * mass_frequency.four_thirds
               + prefactors.five_thirds * mass_frequency.five_thirds
               + prefactors.two         * mass_frequency.two
            );
        
    return phase_ansatz;
}

//Ansatz for the merger-ringdown phase Equation 14 arXiv:1508.07253
//Rholm was added when IMRPhenomHM (high mode) was added.
//Rholm = fRD22/fRDlm. For PhenomD (only (l,m)=(2,2)) this is just equal
//to 1. and PhenomD is recovered.
//Taulm = damping_timelm/damping_time22. Ratio of ringdown damping times.
//Again, when Taulm = 1.0 then PhenomD is recovered.
__device__ __forceinline__ float _calculateMergerRingdownPhaseAnsatz(
    const useful_powers_s      mass_frequency, 
    const phase_coefficients_s coefficients, 
    const float                Rholm, 
    const float                Taulm
    ) {
    
    const float sqrootf  = sqrt(mass_frequency.one);
    const float fpow1_5  = mass_frequency.one * sqrootf;
    const float fpow0_75 = sqrt(fpow1_5);
    
    const float *alpha = coefficients.merger_ringdown;
    
    return 
        - (alpha[1]/mass_frequency.one)
        + (4.0f/3.0f) * (alpha[2] * fpow0_75)
        + alpha[0] * mass_frequency.one
        + alpha[3] * 
            Rholm 
            * atanf(
                  (mass_frequency.one - alpha[4]
                  * coefficients.ringdown_frequency) 
                / (Rholm * coefficients.damping_time * Taulm)
            );
}


// Ansatz for the intermediate phase defined by Equation 16 arXiv:1508.07253
__device__ __forceinline__ float _calculateIntermediatePhaseAnsatz(
    const useful_powers_s      mass_frequency, 
    const phase_coefficients_s coefficients
    ) {
    // 1./eta in paper omitted and put in when need in the functions:
    // ComputeIMRPhenDPhaseConnectionCoefficients
    // IMRPhenDPhase
    
    const float *beta = coefficients.intermediate;

    return 
          beta[0]*mass_frequency.one 
        - beta[2]/(3.0f*_cube(mass_frequency.one)) 
        + beta[1]*logf(mass_frequency.one);
}


__device__ float _calculatePhase(
    const useful_powers_s             mass_frequency, 
    const phase_coefficients_s        coefficients, 
    const phase_inspiral_prefactors_s prefactors, 
    const float                       Rholm, 
    const float                       Taulm
    ) {
    
    // Defined in VIII. Full IMR Waveforms arXiv:1508.07253
    // The inspiral, intermendiate and merger-ringdown phase parts

    // Split the calculation to just 1 of 3 possible mutually exclusive ranges
    float phase = 0.0f;
    // Inspiral range
    if (mass_frequency.one < coefficients.intermediate_start_frequency)        
    {
        phase = 
            _calculateInspiralPhaseAnsatz(
               mass_frequency, 
               prefactors, 
               coefficients            
            );
    }
    // Merger-Ringdown range:
    else if (mass_frequency.one >= coefficients.merger_ringdown_start_frequency) 
    {
        phase = 
            coefficients.etaInv*
            _calculateMergerRingdownPhaseAnsatz(
                mass_frequency, 
                coefficients, 
                Rholm, 
                Taulm
            ) 
            + coefficients.C1MRD 
            + coefficients.C2MRD*mass_frequency.one;
    }
    // Intermediate range:
    else
    {
        phase = 
            coefficients.etaInv*
            _calculateIntermediatePhaseAnsatz(
                mass_frequency, 
                coefficients
            ) 
            + coefficients.C1Int 
            + coefficients.C2Int*mass_frequency.one;
    }
    
    return phase;
}

__global__ void sumFrequenciesPhenomTidal(
          cuFloatComplex                  *strain_fd_g,
    const float                            total_mass_seconds,
    const amplitude_coefficients_s         amplitude_coefficients,
    const amplitude_inspiral_prefactors_s  amplitude_prefactors,
    const phase_coefficients_s             phase_coefficients, 
    const phase_inspiral_prefactors_s                 phase_prefactors, 
    const float                           *tidal_amplitude_array,
    const int32_t                          offset,
    const float                           *frequency_axis_hertz,
    const int32_t                          num_frequency_axis_samples,
    const float                            phase_shift,
    const float                            amp0,
    const float                            reference_mass_frequency,
    const float                            phi_precalc
    ) {
    
    //
    //Description.
    //@param 
    //@see 
    //@return void
    //
    
    // Assign unique thread index for GPU calculation:
    const int32_t sample_index = blockIdx.x * blockDim.x + threadIdx.x;
    
    // If not outside array bounds, add value toa array element:
    if (sample_index < num_frequency_axis_samples) 
	{    
        // Shift index for frequency series if needed:
        const int32_t offset_index = sample_index + offset; 

        // Calculate usefull powers of mass_frequency value:
        const useful_powers_s mass_frequency = 
            _initUsefulPowers(
                total_mass_seconds*frequency_axis_hertz[sample_index]
            );    
        
        // Unpack tidal amplitude value:
        const float tidal_amplitude = tidal_amplitude_array[sample_index];

        // Calculate amplitude value at current sample index:
        const  float amplitude = 
            _calculateAmplitude(
                mass_frequency, 
                amplitude_coefficients, 
                amplitude_prefactors
            );
        
        // Calculate phase value at current sample index:
        const float phase = 
            _calculatePhase(
                mass_frequency, 
                phase_coefficients, 
                phase_prefactors, 
                1.0f, 
                1.0f
            ) 
            - phase_shift*(mass_frequency.one - reference_mass_frequency) 
            + phi_precalc;
                
        // Convert values to cuFloatComplex:
        const cuFloatComplex phase_c = 
            (cuFloatComplex) 
            {
                0.0f,
                -phase
            };
        
        const cuFloatComplex amplitude_c = 
            (cuFloatComplex) 
            {
                amp0*(amplitude + TWO_TIMES_SQRT_PI_OVER_FIVE*tidal_amplitude),
                0.0f
            };
        
        // Calculate strain at current sample_index:
        strain_fd_g[offset_index] = cuCmulf(amplitude_c,cudaCExpf(phase_c));
    }    
}

__global__ void _inclinationAdjust(
          strain_array_s strain,
    const float          cross_factor,
    const float          plus_factor
    ) {
    
    // Assign unique thread index for GPU calculation:
    const int32_t sample_index = blockIdx.x * blockDim.x + threadIdx.x;
    
    // If not outside array bounds, add value toa array element:
    if (sample_index < strain.num_samples) 
	{    
        strain.values[sample_index].plus  *= plus_factor;
        strain.values[sample_index].cross *= cross_factor;
    }    
}

extern "C" waveform_axes_s inclinationAdjust(
    const system_properties_s system_properties,
          waveform_axes_s     waveform_axes_td
    ) {
    
    /*
    float   max_amplitude = 0.0f;
    int32_t max_index     = waveform_axes_td.strain.num_samples - 1;
    
    for (int32_t index = max_index - 1; index > -1; index--)
    {    
        const float amplitude_squared = 
              waveform_axes_td.strain.values[index].plus *waveform_axes_td.strain.values[index].plus 
            + waveform_axes_td.strain.values[index].cross*waveform_axes_td.strain.values[index].cross;
                
        if (amplitude_squared > max_amplitude)
        {
            max_index     = index;
            max_amplitude = amplitude_squared;
        }
    }
    
    //XLALGPSSetREAL8(&(hp->epoch), -1.0*temporal_properties.time_interval.seconds * max_index);
    //XLALGPSSetREAL8(&(hc->epoch), -1.0*temporal_properties.time_interval.seconds * max_index);    
    */
    
    const float cross_factor = cosf(system_properties.inclination.radians);
    const float plus_factor  = 0.5f * (1.0f + cross_factor*cross_factor);
    
    const int32_t grid_size = 
        ((waveform_axes_td.strain.num_samples + BLOCK_SIZE - 1) / BLOCK_SIZE);
    
     _inclinationAdjust<<<grid_size, BLOCK_SIZE>>>(
        waveform_axes_td.strain,
        cross_factor,
        plus_factor
    );
    
    return waveform_axes_td;
}

__global__ void _polarisationRotation(
          strain_array_s strain,
    const float          cos_polarization,
    const float          sin_polarization
    ) {
    
    // Assign unique thread index for GPU calculation:
    const int32_t sample_index = blockIdx.x * blockDim.x + threadIdx.x;
    
    if (sample_index < strain.num_samples) 
    {
        const float temp_plus = strain.values[sample_index].plus;
        strain.values[sample_index].plus = 
            (cos_polarization*strain.values[sample_index].plus)
            + (sin_polarization*strain.values[sample_index].cross);

        strain.values[sample_index].cross = 
            (cos_polarization*strain.values[sample_index].cross) 
            - (sin_polarization*temp_plus);
    }  
}

extern "C" waveform_axes_s polarisationRotation(
    const float           polarization,
          waveform_axes_s waveform_axes_td
    ) {
    
    //R.C.: here's the reference explaining why we perform this rotation https://dcc.ligo.org/LIGO-G1900275
    if (polarization != 0.0f) 
    {        
        const float cos_polarization = cosf(2.0f*polarization);
        const float sin_polarization = sinf(2.0f*polarization);
        
        const int32_t grid_size = 
            ((waveform_axes_td.strain.num_samples + BLOCK_SIZE - 1) / BLOCK_SIZE);
        
        _polarisationRotation<<<grid_size, BLOCK_SIZE>>>(
            waveform_axes_td.strain,
            cos_polarization,
            sin_polarization
        );
    }
    
    return waveform_axes_td;
}

__global__ void _sumPhenomDFrequencies(
          complex_waveform_axes_s         waveform_axes_fd,
    const float                           plus_factor,
    const float                           cross_factor,
    const float                           total_mass_seconds,
    const amplitude_coefficients_s        amplitude_coefficients,
    const amplitude_inspiral_prefactors_s amplitude_prefactors,
    const phase_coefficients_s            phase_coefficients, 
    const phase_inspiral_prefactors_s     phase_prefactors, 
    const int32_t                         offset,
    const float                           phase_shift,
    const float                           amp0,
    const float                           reference_mass_frequency,
    const float                           phi_precalc
    ) {
    
    //
    //Description.
    //@param 
    //@see 
    //@return void
    //
    
    // Assign unique thread index for GPU calculation:
    const int32_t sample_index = blockIdx.x * blockDim.x + threadIdx.x;
    
    // If not outside array bounds sum pheom frequencies:
    if (sample_index < waveform_axes_fd.frequency.num_samples) 
	{    
        // Shift index for frequency series if needed:
        const int32_t offset_index = sample_index + offset; 

        // Calculate usefull powers of mass_frequency value:
        const useful_powers_s mass_frequency = 
            _initUsefulPowers(
                total_mass_seconds*
                    waveform_axes_fd.frequency.values[sample_index].hertz
            );    

        // Calculate amplitude value at current sample index:
        const  float amplitude = 
            _calculateAmplitude(
                mass_frequency, 
                amplitude_coefficients, 
                amplitude_prefactors
            );
        
        // Calculate phase value at current sample index:
        const float phase = 
            _calculatePhase(
                mass_frequency, 
                phase_coefficients, 
                phase_prefactors, 
                1.0f, 
                1.0f
            ) 
            - phase_shift*(mass_frequency.one - reference_mass_frequency) 
            - phi_precalc;
                        
        // Convert values to cuFloatComplex:
        const cuFloatComplex phase_c = 
            (cuFloatComplex) 
            {
                0.0f,
                -1*phase
            };
        
        const cuFloatComplex amplitude_c = 
            (cuFloatComplex) 
            {
                amp0*amplitude,
                0.0f
            };
        
        // Calculate strain at current sample_index:
        waveform_axes_fd.strain.values[offset_index].plus = 
            cuCmulf(amplitude_c,cudaCExpf(phase_c));
    
        // Calcualte plus and cross polarizations:
        waveform_axes_fd.strain.values[offset_index].cross = 
            cuCmulf(
                waveform_axes_fd.strain.values[offset_index].plus, 
                (cuFloatComplex) {0.0f, -1*cross_factor}
            );
            
        waveform_axes_fd.strain.values[offset_index].plus =
            cuCmulf(
                waveform_axes_fd.strain.values[offset_index].plus,
                (cuFloatComplex) {plus_factor, 0.0}
            );
    }    
}

extern "C" int32_t sumPhenomDFrequencies(
          complex_waveform_axes_s         waveform_axes_fd,
    const float                           inclination,
    const float                           total_mass_seconds,
    const amplitude_coefficients_s        amplitude_coefficients,
    const amplitude_inspiral_prefactors_s amplitude_prefactors,
    const phase_coefficients_s            phase_coefficients, 
    const phase_inspiral_prefactors_s     phase_prefactors, 
    const int32_t                         offset,
    const float                           phase_shift,
    const float                           amp0,
    const float                           reference_mass_frequency,
    const float                           phi_precalc
    ) {
    
    const int32_t grid_size = 
        ((waveform_axes_fd.frequency.num_samples + BLOCK_SIZE - 1) / BLOCK_SIZE);
        
    const float cross_factor = cosf(inclination);
    const float plus_factor  = 0.5f * (1.0f + cross_factor*cross_factor);
    
    _sumPhenomDFrequencies<<<grid_size, BLOCK_SIZE>>>(
        waveform_axes_fd,
        plus_factor,
        cross_factor,
        total_mass_seconds,
        amplitude_coefficients,
        amplitude_prefactors,
        phase_coefficients, 
        phase_prefactors, 
        offset,
        phase_shift,
        amp0,
        reference_mass_frequency,
        phi_precalc
    );
    
    return 0;
}

__global__ void _applyPolarization(
    const complex_waveform_axes_s waveform_axes,
    const cuFloatComplex          cos_coefficient,
    const cuFloatComplex          sin_coefficient
    ) {
    
    // Assign unique thread index for GPU calculation:
    const int32_t index = blockIdx.x * blockDim.x + threadIdx.x;
    
    if (index < waveform_axes.strain.num_samples) 
	{
        const cuFloatComplex original_plus = 
            waveform_axes.strain.values[index].plus;
        const cuFloatComplex original_cross = 
            waveform_axes.strain.values[index].cross;
            
        waveform_axes.strain.values[index].plus =
            cuCaddf(
              cuCmulf(cos_coefficient, original_plus),
              cuCmulf(sin_coefficient, original_cross)
            );
        
        waveform_axes.strain.values[index].cross = 
            cuCsubf(
              cuCmulf(cos_coefficient, original_cross),
              cuCmulf(sin_coefficient, original_plus)
            );
    }
}

extern "C" int32_t applyPolarization(
    const complex_waveform_axes_s waveform_axes,
    const float                   polarization
    ) {
    
    const int32_t grid_size = 
        ((waveform_axes.strain.num_samples + BLOCK_SIZE - 1) / BLOCK_SIZE);
    
    const cuFloatComplex cos_coefficient = 
         (cuFloatComplex) {cosf(2.0f*polarization), 0.0f};
    const cuFloatComplex sin_coefficient = 
         (cuFloatComplex) {sinf(2.0f*polarization), 0.0f};
    
    _applyPolarization<<<grid_size, BLOCK_SIZE>>>(
        waveform_axes,
        cos_coefficient,
        sin_coefficient
    );

    return 0;
}

__global__ void _taperWaveform(
    const complex_waveform_axes_s waveform_axes,
    const int32_t                 start_index,
    const int32_t                 end_index
    ) {
    
    // Assign unique thread index for GPU calculation:
    const int32_t index = blockIdx.x * blockDim.x + threadIdx.x;
    
    if (index < start_index) 
	{
        // Ensure strain is zero below start_frequency:
        const cuFloatComplex complex_zero =
            (cuFloatComplex) {0.0f, 0.0f};
        
        waveform_axes.strain.values[index].plus  = complex_zero;
        waveform_axes.strain.values[index].cross = complex_zero;
    }
    else if (index < end_index)
    {
        // Taper waveform between start_frequency and minimum_frequency:
        const float taper_scalar = 
              0.5f 
            - 0.5f*cosf(
                (float)M_PI
                *(float)(index - start_index) 
                /(float)(end_index - start_index)
            );
            
        const cuFloatComplex complex_scalar = 
            (cuFloatComplex) {taper_scalar, 0.0f};

        waveform_axes.strain.values[index].plus = 
            cuCmulf(waveform_axes.strain.values[index].plus, complex_scalar);
        waveform_axes.strain.values[index].cross = 
            cuCmulf(waveform_axes.strain.values[index].cross, complex_scalar);
    }
}

__global__ void _zeroNyquistFrequency(
    const complex_waveform_axes_s waveform_axes
    ) {
    
    // Make sure Nyquist frequency is zero:
    waveform_axes.strain.values[waveform_axes.strain.num_samples - 1].plus  = 
        (cuFloatComplex) {0.0f, 0.0f};
    waveform_axes.strain.values[waveform_axes.strain.num_samples - 1].cross =
        (cuFloatComplex) {0.0f, 0.0f};
}

extern "C" int32_t taperWaveform(
    const complex_waveform_axes_s waveform_axes,
    const float                   starting_frequency,
    const float                   minimum_frequency,
    const float                   frequency_interval
    ) {
    
    //
    // Taper frequencies between starting_frequency and minimum_frequency 
    //
        
    // Calculate sample indicies of start and minimum frequencies:
    const int32_t start_index = 
        (int32_t)roundf(starting_frequency/frequency_interval);
    const int32_t end_index = 
        (int32_t)roundf(minimum_frequency/frequency_interval);
    
    // Perform tapering on device:
    const int32_t grid_size = 
        ((end_index + BLOCK_SIZE - 1) / BLOCK_SIZE);
    _taperWaveform<<<grid_size, BLOCK_SIZE>>>
        (waveform_axes, start_index, end_index);
        
    _zeroNyquistFrequency<<<1, 1>>>(
        waveform_axes
    );
    
    return 0;
}

__device__ frequencyUnit_t _initFrequencyHertz(
	const float frequency_hertz
	) {
	
	frequencyUnit_t frequency = {
		 .hertz = frequency_hertz
	 };
	
	return frequency;
}

__global__ void _printSystemProperties(
    const system_properties_s *system_properties
    ) {

    printf("%f %f %f %f\n",
        system_properties[0].companion[0].mass.msun,
        system_properties[0].companion[0].mass.kilograms,
        system_properties[0].companion[0].mass.seconds,
        system_properties[0].companion[0].mass.meters
    );
    
    printf("%f %f %f %f\n",
        system_properties[1].companion[0].mass.msun,
        system_properties[1].companion[0].mass.kilograms,
        system_properties[1].companion[0].mass.seconds,
        system_properties[1].companion[0].mass.meters
    );
}

extern "C" void printSystemProperties(
    const system_properties_s *system_properties
    ) {
    
    _printSystemProperties<<<1,1>>>(system_properties);
}

__global__ void _calcNumStrainAxisSamples(
          temporal_properties_s *temporal_properties,
    const system_properties_s   *system_properties,
          float                 *num_strain_axis_samples,
    const int32_t                num_waveforms
    ) {
    
    // Assign unique thread index for GPU calculation:
    const int32_t waveform_index = blockIdx.x * blockDim.x + threadIdx.x;
    
    if (waveform_index < num_waveforms) 
	{
        // Unpack temporal_properties:
        const frequencyUnit_t ending_frequency = 
            temporal_properties[waveform_index].ending_frequency;
        const frequencyUnit_t starting_frequency = 
            temporal_properties[waveform_index].starting_frequency;
        const frequencyUnit_t frequency_interval = 
            temporal_properties[waveform_index].frequency_interval; 
        const frequencyUnit_t reference_frequency = 
            temporal_properties[waveform_index].reference_frequency; 
        
        // If no reference frequency given, set it to the starting GW frequency:
        temporal_properties[waveform_index].reference_frequency.hertz = 
                  (reference_frequency.hertz > 0.0f)*reference_frequency.hertz 
                + (reference_frequency.hertz == 0.0f)*starting_frequency.hertz;     
        
        // Somewhat arbitrary end point for the waveform chosen so that the end 
        // of the waveform is well after the ringdown:
        const frequencyUnit_t cutoff_frequency = 
            _initFrequencyHertz(
                f_CUT/system_properties[waveform_index].total_mass.seconds
            );
            
        if (cutoff_frequency.hertz <= starting_frequency.hertz) 
        {
            printf(
               "%s:\n"
               "Warning! (cutoff_frequency: %fHz) <= (starting_frequency = %fHz)\n",
                __func__,
                cutoff_frequency.hertz,
                starting_frequency.hertz
            );
        }
                
        // If no ending frequency given, set it to cuttoff frequency: 
        temporal_properties[waveform_index].ending_frequency.hertz =
            (ending_frequency.hertz > 0.0f)*ending_frequency.hertz 
            + (ending_frequency.hertz == 0.0f)*cutoff_frequency.hertz;
            
        frequencyUnit_t new_ending_frequency = 
            temporal_properties[waveform_index].ending_frequency;
        
        // If no ending frequency given, set it to cuttoff frequency: 
        temporal_properties[waveform_index].ending_frequency.hertz = 
                (new_ending_frequency.hertz > cutoff_frequency.hertz) ? 
                    cutoff_frequency.hertz : new_ending_frequency.hertz;
            
        new_ending_frequency = 
            temporal_properties[waveform_index].ending_frequency;
                
        if (new_ending_frequency.hertz <= starting_frequency.hertz)
        {
            printf(
                "%s:\n"
                "Warning! new_ending_frequency (%f) Hz <= starting_frequency"
                " (%f) Hz, for waveform (%i).\n",
                __func__,
                new_ending_frequency.hertz,
                starting_frequency.hertz,
                waveform_index
            );
        }
        
        if (new_ending_frequency.hertz > ending_frequency.hertz)
        {
        
            num_strain_axis_samples[waveform_index] = 
                _calcNextPow2(
                    new_ending_frequency.hertz / frequency_interval.hertz
                ) + 1;
        }
        else
        {
            // The user has requested a higher old_ending_frequency than 
            // Mf=frequency_cutoff.resize the frequency series to fill with zeros 
            // beyond the cutoff frequency:
            num_strain_axis_samples[waveform_index] = 
                _calcNextPow2(
                    ending_frequency.hertz / frequency_interval.hertz
                ) + 1; 
            // We actually want to have the length be a power of 2 + 1.
        }
    }
}

extern "C" int32_t calcNumStrainAxisSamples(
          temporal_properties_s *temporal_properties,
    const system_properties_s   *system_properties,
    const int32_t                num_waveforms
    ) {
    
    float *num_strain_axis_samples = NULL;
    CUDA_CALL(
        cudaMalloc(
            (void**)&num_strain_axis_samples, 
            sizeof(float)*(size_t)num_waveforms
        )
    );
    
    const int32_t grid_size = 
        ((num_waveforms + BLOCK_SIZE - 1) / BLOCK_SIZE);
    
    _calcNumStrainAxisSamples<<<grid_size, BLOCK_SIZE>>>(
        temporal_properties,
        system_properties,
        num_strain_axis_samples,
        num_waveforms
    );
    
    const int32_t max_num_strain_axis_samples = 
        (int32_t) cudaFindMaxHost(
            num_strain_axis_samples, 
            num_waveforms
        );
        
    return max_num_strain_axis_samples;
}

__global__ void _calcNumFrequencyAxisSamples(
    const temporal_properties_s *temporal_properties,
          float                 *num_strain_axis_samples,
          float                 *num_frequency_axis_samples,
    const int32_t                num_waveforms
    ) {
    
    // Assign unique thread index for GPU calculation:
    const int32_t waveform_index = blockIdx.x * blockDim.x + threadIdx.x;
    
    // If not outside array bounds, add value toa array element:
    if (waveform_index < num_waveforms) 
	{   
        const frequencyUnit_t starting_frequency = 
            temporal_properties[waveform_index].starting_frequency;
        const frequencyUnit_t ending_frequency   = 
            temporal_properties[waveform_index].ending_frequency;
        const frequencyUnit_t frequency_interval = 
            temporal_properties[waveform_index].frequency_interval;
            
        // Initilise frequency array using the upper and lower bounds:
        const float start_index = 
            roundf(starting_frequency.hertz 
                / frequency_interval.hertz);
        const float end_index = 
            roundf(ending_frequency.hertz 
                / frequency_interval.hertz);
                
        num_frequency_axis_samples[waveform_index] = 
            end_index - start_index;
            
        // Error check indicies:
        if (end_index >= num_strain_axis_samples[waveform_index])
        {
            printf(
                "%s:\n"
                "Error! Calculated end_index (%f) is greater than "
                "num_strain_axis_samples (%f)! For waveform (%i). Exiting!",
                __func__, 
                end_index, 
                num_strain_axis_samples[waveform_index], 
                waveform_index
            );
        }
        else if (start_index >= end_index)
        {
            printf(
                "%s:\n"
                "Error! Calculated start_index (%f) is greater than end_index "
                "(%f)! For waveform (%i). Exiting!",
                __func__, 
                start_index, 
                end_index, 
                waveform_index
            );
        }
    }
}

extern "C" int32_t calcNumFrequencyAxisSamples(
    const temporal_properties_s *temporal_properties,
          float                 *num_strain_axis_samples,
    const int32_t                num_waveforms
    ) {
        
    float *num_frequency_axis_samples = NULL;
    CUDA_CALL(
        cudaMalloc(
            (void**)&num_frequency_axis_samples, 
            sizeof(float)*(size_t)num_waveforms
        )
    );
    
    const int32_t grid_size = 
        ((num_waveforms + BLOCK_SIZE - 1) / BLOCK_SIZE);
    
    _calcNumFrequencyAxisSamples<<<grid_size, BLOCK_SIZE>>>(
        temporal_properties,
        num_strain_axis_samples,
        num_frequency_axis_samples,
        num_waveforms
    );
    
    const int32_t max_num_frequency_axis_samples = 
        (int32_t) cudaFindMaxHost(
            num_frequency_axis_samples, 
            num_waveforms
        );
        
    return max_num_frequency_axis_samples;
}

extern "C" m_complex_waveform_axes_s initPhenomDWaveformAxes(
          temporal_properties_s *temporal_properties,
          system_properties_s   *system_properties,
    const int32_t                num_waveforms
    ) {
    
    float *num_strain_axis_samples_in_waveform = NULL;
    cudaAllocateDeviceMemory(
        sizeof(float), 
        num_waveforms,
        (void**)&num_strain_axis_samples_in_waveform
    );
    
    const int32_t grid_size = 
        ((num_waveforms + BLOCK_SIZE - 1) / BLOCK_SIZE);
    
    _calcNumStrainAxisSamples<<<grid_size, BLOCK_SIZE>>>(
        temporal_properties,
        system_properties,
        num_strain_axis_samples_in_waveform,
        num_waveforms
    );
    
    int32_t max_num_strain_axis_samples_per_waveform = 
        (int32_t) cudaFindMaxHost(
            num_strain_axis_samples_in_waveform, 
            num_waveforms
        );
        
    int32_t total_num_strain_axis_samples = 
        max_num_strain_axis_samples_per_waveform * num_waveforms;
    
    complex_strain_element_c *strain_axis_values = NULL;
    cudaCallocateDeviceMemory(
        sizeof(complex_strain_element_c), 
        total_num_strain_axis_samples,
        (void**)&strain_axis_values
    );
    
    m_complex_strain_array_s strain_axis = 
    {
        .values                       = strain_axis_values,
        .num_samples_in_waveform      = num_strain_axis_samples_in_waveform,
        .max_num_samples_per_waveform = max_num_strain_axis_samples_per_waveform,
        .total_num_samples            = total_num_strain_axis_samples
    };
    
    float *num_frequency_axis_samples_in_waveform = NULL;
    cudaAllocateDeviceMemory(
        sizeof(float), 
        num_waveforms,
        (void**)&num_frequency_axis_samples_in_waveform
    );
    
    _calcNumFrequencyAxisSamples<<<grid_size, BLOCK_SIZE>>>(
        temporal_properties,
        num_strain_axis_samples_in_waveform,
        num_frequency_axis_samples_in_waveform,
        num_waveforms
    );
    const int32_t max_num_frequency_axis_samples_per_waveform = 
        (int32_t) cudaFindMaxHost(
            num_frequency_axis_samples_in_waveform, 
            num_waveforms
        );
        
    const int32_t total_num_frequency_axis_samples = 
        max_num_frequency_axis_samples_per_waveform * num_waveforms;
    
    frequencyUnit_t *frequency_axis_values = NULL;
    cudaCallocateDeviceMemory(
        sizeof(frequencyUnit_t), 
        total_num_frequency_axis_samples,
        (void**)&frequency_axis_values
    );
    
    frequencyUnit_t *frequency_interval_of_waveform = NULL;
    cudaCallocateDeviceMemory(
        sizeof(timeUnit_t), 
        num_waveforms,
        (void**)&frequency_interval_of_waveform
    );
        
    m_frequency_array_s frequency_axis = 
    {
        .values                       = frequency_axis_values,
        .interval_of_waveform         = frequency_interval_of_waveform,
        .num_samples_in_waveform      = num_frequency_axis_samples_in_waveform,
        .max_num_samples_per_waveform = max_num_frequency_axis_samples_per_waveform,
        .total_num_samples            = total_num_frequency_axis_samples
    };

    timeUnit_t *time_interval_of_waveform = NULL;
    cudaCallocateDeviceMemory(
        sizeof(timeUnit_t), 
        num_waveforms,
        (void**)&time_interval_of_waveform
    );
    
    m_time_array_s empty_time_axis = 
    {
        .values                       = NULL,
        .interval_of_waveform         = time_interval_of_waveform,
        .num_samples_in_waveform      = NULL,
        .max_num_samples_per_waveform = 0,
        .total_num_samples            = 0
    };
    
    timeUnit_t *merger_time_for_waveform = NULL;
    cudaCallocateDeviceMemory(
        sizeof(timeUnit_t), 
        num_waveforms,
        (void**)&merger_time_for_waveform
    );
    
    // Construct Waveform Axes:
    m_complex_waveform_axes_s complex_waveform_axes = 
    {
        .merger_time_for_waveform        = merger_time_for_waveform,
        .frequency                       = frequency_axis,
        .time                            = empty_time_axis,
        .strain                          = strain_axis,
        .temporal_properties_of_waveform = temporal_properties,
        .system_properties_of_waveform   = system_properties,
        .num_waveforms                   = num_waveforms
    };
    
    return complex_waveform_axes;
}

#endif